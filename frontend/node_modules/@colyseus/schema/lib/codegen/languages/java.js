"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
var types_1 = require("../types");
var typeMaps = {
    "string": "String",
    "number": "float",
    "boolean": "boolean",
    "int8": "byte",
    "uint8": "short",
    "int16": "short",
    "uint16": "int",
    "int32": "int",
    "uint32": "long",
    "int64": "long",
    "uint64": "long",
    "float32": "float",
    "float64": "double",
};
var typeInitializer = {
    "string": '""',
    "number": "0",
    "boolean": "false",
    "int8": "0",
    "uint8": "0",
    "int16": "0",
    "uint16": "0",
    "int32": "0",
    "uint32": "0",
    "int64": "0",
    "uint64": "0",
    "float32": "0",
    "float64": "0",
};
/**
 * C# Code Generator
 */
function generate(context, options) {
    return context.classes.map(function (klass) { return ({
        name: klass.name + ".java",
        content: generateClass(klass, options.namespace)
    }); });
}
exports.generate = generate;
function generateClass(klass, namespace) {
    var indent = (namespace) ? "\t" : "";
    return "".concat((0, types_1.getCommentHeader)(), "\n").concat(namespace ? "\npackage ".concat(namespace, ";") : "", "\n\nimport io.colyseus.serializer.schema.Schema;\nimport io.colyseus.serializer.schema.annotations.SchemaClass;\nimport io.colyseus.serializer.schema.annotations.SchemaField;\n\n@SchemaClass\n").concat(indent, "public class ").concat(klass.name, " extends ").concat(klass.extends, " {\n").concat(klass.properties.map(function (prop) { return generateProperty(prop, indent); }).join("\n\n"), "\n").concat(indent, "}\n").concat(namespace ? "}" : "", "\n");
}
function generateProperty(prop, indent) {
    if (indent === void 0) { indent = ""; }
    var typeArgs = "".concat(prop.index, "/").concat(prop.type);
    var property = "public";
    var langType;
    var ctorArgs = "";
    var initializer = "";
    if (prop.childType) {
        var isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (prop.type !== "ref" && isUpcaseFirst) {
            ctorArgs = "".concat(prop.childType, ".class");
        }
        if (prop.type === "ref") {
            langType = (isUpcaseFirst)
                ? prop.childType
                : typeMaps[prop.childType];
            initializer = "new ".concat(langType).concat((prop.type !== "ref" && isUpcaseFirst) ? "<>" : "", "(").concat(ctorArgs, ")");
        }
        else if (prop.type === "array") {
            langType = (isUpcaseFirst)
                ? "ArraySchema<".concat(prop.childType, ">")
                : "ArraySchema";
            initializer = "new ArraySchema".concat((isUpcaseFirst) ? "<>" : "", "(").concat(ctorArgs, ")");
        }
        else if (prop.type === "map") {
            langType = (isUpcaseFirst)
                ? "MapSchema<".concat(prop.childType, ">")
                : "MapSchema";
            initializer = "new MapSchema".concat((isUpcaseFirst) ? "<>" : "", "(").concat(ctorArgs, ")");
        }
        if (prop.type !== "ref") {
            typeArgs += (isUpcaseFirst)
                ? "/ref"
                : "/".concat(prop.childType);
        }
    }
    else {
        langType = typeMaps[prop.type];
        initializer = typeInitializer[prop.type];
    }
    property += " ".concat(langType, " ").concat(prop.name);
    return "\t@SchemaField(\"".concat(typeArgs, "\")\t").concat(indent, "\n\t").concat(indent).concat(property, " = ").concat(initializer, ";");
}
//# sourceMappingURL=java.js.map