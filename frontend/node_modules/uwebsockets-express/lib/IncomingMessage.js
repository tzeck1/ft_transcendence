"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _IncomingMessage__originalUrlParsed;
Object.defineProperty(exports, "__esModule", { value: true });
exports.IncomingMessage = void 0;
const querystring_1 = __importDefault(require("querystring"));
const events_1 = __importDefault(require("events"));
const url_1 = require("url");
const Socket_1 = require("./Socket");
const express_1 = require("express");
const READ_BODY_MAX_TIME = 500;
class IncomingMessage extends events_1.default {
    constructor(req, res, parameterNames, app) {
        super();
        this.req = req;
        this.res = res;
        this.parameterNames = parameterNames;
        this.app = app;
        // public query: querystring.ParsedUrlQuery;
        // private _url: string;
        // private _path: string;
        this._baseUrl = "";
        this._headers = {};
        this._readableState = { pipes: [] };
        // @ts-ignore
        this.socket = new Socket_1.Socket(false, true);
        _IncomingMessage__originalUrlParsed.set(this, void 0);
        this._headers = {};
        this.req.forEach((key, value) => {
            this._headers[key] = value;
            // workaround: also consider 'referrer'
            if (key === "referer") {
                this._headers['referrer'] = value;
            }
        });
        this.url = this.req.getUrl();
        this.method = this.req.getMethod().toUpperCase();
        this._rawquery = this.req.getQuery();
        this._remoteAddress = this.res.getRemoteAddressAsText();
        if (this._rawquery) {
            this.url += `?${this._rawquery}`;
        }
        __classPrivateFieldSet(this, _IncomingMessage__originalUrlParsed, new url_1.URL(`http://server${this.url}`), "f");
    }
    get ip() {
        return Buffer.from(this._remoteAddress).toString();
    }
    set body(_body) {
        this._bodydata = _body;
    }
    get body() {
        return this._bodydata || this._rawbody;
    }
    get headers() {
        return this._headers;
    }
    set params(value) {
        this._params = value;
    }
    get params() {
        if (!this._params) {
            this._params = {};
            for (let i = 0; i < this.parameterNames.length; i++) {
                const paramName = this.parameterNames[i];
                this._params[paramName] = this.req.getParameter(i);
            }
        }
        return this._params;
    }
    get query() {
        if (!this._query)
            this._query = querystring_1.default.parse(this._rawquery);
        return this._query;
    }
    get baseUrl() {
        return this._baseUrl;
    }
    set baseUrl(baseUrl) {
        this._baseUrl = baseUrl;
    }
    get path() {
        const path = __classPrivateFieldGet(this, _IncomingMessage__originalUrlParsed, "f").pathname.replace(this._baseUrl, "");
        return (!path.startsWith("/"))
            ? `/${path}`
            : path;
    }
    get(name) {
        return this.header(name);
    }
    header(name) {
        name = name.toLowerCase();
        return this._headers[name] || undefined;
    }
    accepts(...args) {
        return express_1.request.accepts.apply(this, arguments);
    }
    resume() { return this; }
    on(event, listener) {
        if (event === 'data' && this._rawbody !== undefined) {
            /**
             * req.body is synchronously before any middleware runs.
             * here we're mimicking to trigger 'data' + 'end' + 'close' right at the moment the event is registered.
             */
            setImmediate(() => {
                listener(this._rawbody);
                this.emit('end');
                this.emit('close');
            });
        }
        else {
            super.on(event, listener);
        }
        return this;
    }
    readBody() {
        return new Promise((resolve, reject) => {
            let body;
            //
            // ensure request is not halted when an invalid content-length is sent by the client
            // https://github.com/endel/uWebSockets-express/issues/9
            //
            const rejectionTimeout = setTimeout(() => {
                if (body) {
                    this._rawbody = body.toString();
                    this.headers['content-length'] = String(body.length);
                }
                reject();
            }, READ_BODY_MAX_TIME);
            this.res.onData((arrayBuffer, isLast) => {
                const chunk = Buffer.from(arrayBuffer);
                body = (body && body.length !== 0) ? Buffer.concat([body, chunk]) : chunk;
                if (isLast) {
                    clearTimeout(rejectionTimeout);
                    this._rawbody = body.toString();
                    resolve(this._rawbody !== "");
                }
            });
        });
    }
}
exports.IncomingMessage = IncomingMessage;
_IncomingMessage__originalUrlParsed = new WeakMap();
//# sourceMappingURL=IncomingMessage.js.map