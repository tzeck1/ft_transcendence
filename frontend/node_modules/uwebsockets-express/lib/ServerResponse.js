"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerResponse = void 0;
const fs_1 = __importDefault(require("fs"));
const mime_1 = __importDefault(require("mime"));
const events_1 = __importDefault(require("events"));
const http_status_codes_1 = require("http-status-codes");
const express_1 = require("express");
const http_1 = __importDefault(require("http"));
const utils_merge_1 = __importDefault(require("utils-merge"));
const cookie_1 = __importDefault(require("cookie"));
const cookie_signature_1 = require("cookie-signature");
class ServerResponse extends events_1.default /* implements http.ServerResponse */ {
    constructor(res, req, app) {
        super();
        this.res = res;
        this.req = req;
        this.app = app;
        this._headers = {};
        this._writes = [];
        this.statusCode = 200;
        // public socket = new Socket(true, false);
        this.headersSent = false;
        this.finished = false;
        this.locals = {};
        this.writableEnded = false;
        http_1.default.OutgoingMessage.call(this);
    }
    render(view, callback) {
        express_1.response.render.apply(this, arguments);
    }
    end(chunk, encoding) {
        if (this.finished) {
            return;
        }
        let body = chunk;
        if (encoding) {
            body = Buffer.from(chunk, encoding).toString();
        }
        if (!this.writableEnded) {
            // write status + headers
            this.writeHead(this.statusCode || this.statusCode, this._headers);
            // dequeue writes
            this._writes.forEach((chunk) => this.res.write(chunk));
            // write response
            this.res.end(body);
        }
        // this.writableEnded = true;
        this.finished = true;
        this.emit('finish');
        return this;
    }
    get(name) {
        return this._headers[name.toLowerCase()];
    }
    hasHeader(name) {
        return (this._headers[name.toLowerCase()] !== undefined);
    }
    getHeader(name) {
        this.get(name);
    }
    setHeader(name, value) {
        this.set(name, value);
    }
    removeHeader(name) {
        delete this._headers[name.toLowerCase()];
    }
    status(code) {
        this.statusCode = code;
        return this;
    }
    sendStatus(statusCode) {
        this.status(statusCode);
        return this;
    }
    vary(field) {
        let append = "";
        if (!this._headers['vary']) {
            this._headers['vary'] = "";
            append = field;
        }
        else {
            append = `, ${field}`;
        }
        this._headers['vary'] += append;
    }
    sendFile(path, fn) {
        this.type(path);
        fs_1.default.readFile(path, (err, contents) => {
            if (err)
                return fn(err);
            this.send(contents);
        });
    }
    send(chunk) {
        switch (typeof chunk) {
            // string defaulting to html
            case 'string':
                if (!this.get('Content-Type')) {
                    this.type('html');
                }
                break;
            case 'boolean':
            case 'number':
            case 'object':
                if (chunk === null) {
                    chunk = '';
                }
                else if (Buffer.isBuffer(chunk)) {
                    if (!this.get('Content-Type')) {
                        this.type('bin');
                    }
                }
                else {
                    return this.json(chunk);
                }
                break;
        }
        return this.end(chunk);
    }
    // enqueue to write during .end()
    write(chunk) {
        this._writes.push(chunk);
        return this;
    }
    type(type) {
        this.set('Content-Type', mime_1.default.getType(type) || type);
        return this;
    }
    json(body) {
        this.type('json').end(JSON.stringify(body));
    }
    jsonp(body) {
        this.set('Content-Type', "application/javascript");
        this.end(`callback(${JSON.stringify(body)})`);
    }
    location(url) {
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location
        return express_1.response.location.apply(this, arguments);
    }
    redirect(codeOrPath, path) {
        return express_1.response.redirect.apply(this, arguments);
        // if (arguments.length === 1) {
        //   path = codeOrPath as string;
        //   codeOrPath = 302;
        // }
        // this.
        //   status(codeOrPath as number).
        //   location(path).
        //   end();
    }
    format(obj) {
        return express_1.response.format.apply(this, arguments);
    }
    set(name, value) {
        if (typeof (name) === "string") {
            name = name.toLowerCase();
            if (name !== 'content-length') {
                this._headers[name] = value;
            }
        }
        else {
            for (let _name in name) {
                _name = _name.toLowerCase();
                if (_name !== 'content-length') {
                    this._headers[_name] = name[_name];
                }
            }
        }
        return this;
    }
    append(name, val) {
        const prev = this.get(name);
        let value = val;
        if (prev) {
            // concat the new and prev vals
            value = Array.isArray(prev) ? prev.concat(val)
                : Array.isArray(val) ? [prev].concat(val)
                    : [prev, val];
        }
        return this.set(name, value);
    }
    // alias to "set"
    header(name, value) {
        return this.set(name, value);
    }
    writeHead(code, headers = this._headers) {
        var _a;
        if (this.headersSent) {
            console.warn("writeHead: headers were already sent.");
            return;
        }
        // write status
        const reason = http_status_codes_1.ReasonPhrases[http_status_codes_1.StatusCodes[code]];
        this.res.writeStatus(`${code} ${reason}`);
        // write headers
        for (const name in headers) {
            if (Array.isArray(headers[name])) {
                for (const headerValue of headers[name]) {
                    this.res.writeHeader(name, headerValue === null || headerValue === void 0 ? void 0 : headerValue.toString());
                }
            }
            else {
                this.res.writeHeader(name, (_a = headers[name]) === null || _a === void 0 ? void 0 : _a.toString());
            }
        }
        this.headersSent = true;
    }
    cookie(name, value, options) {
        const opts = utils_merge_1.default({}, options);
        const secret = this.req.secret || null;
        const signed = opts.signed || false;
        if (signed && !secret) {
            throw new Error('cookieParser("secret") required for signed cookies');
        }
        let val = typeof value === 'object'
            ? 'j:' + JSON.stringify(value)
            : String(value);
        if (signed) {
            val = 's:' + cookie_signature_1.sign(val, secret);
        }
        if ('maxAge' in opts) {
            opts.expires = new Date(Date.now() + opts.maxAge);
            opts.maxAge /= 1000;
        }
        if (opts.path == null) {
            opts.path = '/';
        }
        return this.append('Set-Cookie', cookie_1.default.serialize(name, String(val), opts));
    }
    clearCookie(name, options) {
        const opts = utils_merge_1.default({ expires: new Date(1), path: '/' }, options);
        return this.cookie(name, '', opts);
    }
    // express-session [??]
    _implicitHeader() {
        const code = http_status_codes_1.StatusCodes.OK;
        const reason = http_status_codes_1.ReasonPhrases[http_status_codes_1.StatusCodes[code]];
        this.res.writeStatus(`${code} ${reason}`);
    }
}
exports.ServerResponse = ServerResponse;
//# sourceMappingURL=ServerResponse.js.map