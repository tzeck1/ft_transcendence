"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
var types_1 = require("../types");
var typeMaps = {
    "string": "string",
    "number": "float",
    "boolean": "bool",
    "int8": "sbyte",
    "uint8": "byte",
    "int16": "short",
    "uint16": "ushort",
    "int32": "int",
    "uint32": "uint",
    "int64": "long",
    "uint64": "ulong",
    "float32": "float",
    "float64": "double",
};
/**
 * C# Code Generator
 */
var capitalize = function (s) {
    if (typeof s !== 'string')
        return '';
    return s.charAt(0).toUpperCase() + s.slice(1);
};
function generate(context, options) {
    // enrich typeMaps with enums
    context.enums.forEach(function (structure) {
        typeMaps[structure.name] = structure.name;
    });
    return __spreadArray(__spreadArray(__spreadArray([], __read(context.classes.map(function (structure) { return ({
        name: "".concat(structure.name, ".cs"),
        content: generateClass(structure, options.namespace)
    }); })), false), __read(context.interfaces.map(function (structure) { return ({
        name: "".concat(structure.name, ".cs"),
        content: generateInterface(structure, options.namespace),
    }); })), false), __read(context.enums.filter(function (structure) { return structure.name !== 'OPERATION'; }).map(function (structure) { return ({
        name: "".concat(structure.name, ".cs"),
        content: generateEnum(structure, options.namespace),
    }); })), false);
}
exports.generate = generate;
function generateClass(klass, namespace) {
    var indent = (namespace) ? "\t" : "";
    return "".concat((0, types_1.getCommentHeader)(), "\n\nusing Colyseus.Schema;\n").concat(namespace ? "\nnamespace ".concat(namespace, " {") : "", "\n").concat(indent, "public partial class ").concat(klass.name, " : ").concat(klass.extends, " {\n").concat(klass.properties.map(function (prop) { return generateProperty(prop, indent); }).join("\n\n"), "\n").concat(indent, "}\n").concat(namespace ? "}" : "", "\n");
}
function generateEnum(_enum, namespace) {
    var indent = namespace ? "\t" : "";
    return "".concat((0, types_1.getCommentHeader)(), "\n").concat(namespace ? "\nnamespace ".concat(namespace, " {") : "", "\n").concat(indent, "public struct ").concat(_enum.name, " {\n\n").concat(_enum.properties
        .map(function (prop) {
        var dataType = "int";
        var value;
        if (prop.type) {
            if (isNaN(Number(prop.type))) {
                value = prop.type;
                dataType = "string";
            }
            else {
                value = Number(prop.type);
                dataType = Number.isInteger(value) ? 'int' : 'float';
            }
        }
        else {
            value = _enum.properties.indexOf(prop);
        }
        return "".concat(indent, "\tpublic const ").concat(dataType, " ").concat(prop.name, " = ").concat(value, ";");
    })
        .join("\n"), "\n").concat(indent, "}");
}
function generateProperty(prop, indent) {
    if (indent === void 0) { indent = ""; }
    var typeArgs = "\"".concat(prop.type, "\"");
    var property = "public";
    var langType;
    var initializer = "";
    if (prop.childType) {
        var isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (prop.type === "ref") {
            langType = (isUpcaseFirst)
                ? prop.childType
                : getChildType(prop);
        }
        else {
            var containerClass = capitalize(prop.type);
            langType = (isUpcaseFirst)
                ? "".concat(containerClass, "Schema<").concat(prop.childType, ">")
                : "".concat(containerClass, "Schema<").concat(getChildType(prop), ">");
        }
        typeArgs += ", typeof(".concat(langType, ")");
        if (!isUpcaseFirst) {
            typeArgs += ", \"".concat(prop.childType, "\"");
        }
        initializer = "new ".concat(langType, "()");
    }
    else {
        langType = getType(prop);
        initializer = "default(".concat(langType, ")");
    }
    property += " ".concat(langType, " ").concat(prop.name);
    var ret = (prop.deprecated) ? "\t\t[System.Obsolete(\"field '".concat(prop.name, "' is deprecated.\", true)]\n") : '';
    return ret + "\t".concat(indent, "[Type(").concat(prop.index, ", ").concat(typeArgs, ")]\n\t").concat(indent).concat(property, " = ").concat(initializer, ";");
}
function generateInterface(struct, namespace) {
    var indent = (namespace) ? "\t" : "";
    return "".concat((0, types_1.getCommentHeader)(), "\n\nusing Colyseus.Schema;\n").concat(namespace ? "\nnamespace ".concat(namespace, " {") : "", "\n").concat(indent, "public class ").concat(struct.name, " {\n").concat(struct.properties.map(function (prop) { return "\t".concat(indent, "public ").concat(getType(prop), " ").concat(prop.name, ";"); }).join("\n"), "\n").concat(indent, "}\n").concat(namespace ? "}" : "", "\n");
}
function getChildType(prop) {
    return typeMaps[prop.childType];
}
function getType(prop) {
    return (prop.type === "array")
        ? "".concat(typeMaps[prop.childType] || prop.childType, "[]")
        : typeMaps[prop.type];
}
//# sourceMappingURL=csharp.js.map