"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
var types_1 = require("../types");
var typeMaps = {
    "string": "string",
    "number": "varint_t",
    "boolean": "bool",
    "int8": "int8_t",
    "uint8": "uint8_t",
    "int16": "int16_t",
    "uint16": "uint16_t",
    "int32": "int32_t",
    "uint32": "uint32_t",
    "int64": "int64_t",
    "uint64": "uint64_t",
    "float32": "float32_t",
    "float64": "float64_t",
};
var typeInitializer = {
    "string": '""',
    "number": "0",
    "boolean": "false",
    "int8": "0",
    "uint8": "0",
    "int16": "0",
    "uint16": "0",
    "int32": "0",
    "uint32": "0",
    "int64": "0",
    "uint64": "0",
    "float32": "0",
    "float64": "0",
};
/**
 * C++ Code Generator
 */
var capitalize = function (s) {
    if (typeof s !== 'string')
        return '';
    return s.charAt(0).toUpperCase() + s.slice(1);
};
var distinct = function (value, index, self) { return self.indexOf(value) === index; };
function generate(context, options) {
    return context.classes.map(function (klass) { return ({
        name: klass.name + ".hpp",
        content: generateClass(klass, options.namespace, context.classes)
    }); });
}
exports.generate = generate;
function generateClass(klass, namespace, allClasses) {
    var propertiesPerType = {};
    var allRefs = [];
    klass.properties.forEach(function (property) {
        var type = property.type;
        if (!propertiesPerType[type]) {
            propertiesPerType[type] = [];
        }
        propertiesPerType[type].push(property);
        // keep all refs list
        if ((type === "ref" || type === "array" || type === "map")) {
            allRefs.push(property);
        }
    });
    var allProperties = getAllProperties(klass, allClasses);
    var createInstanceMethod = (allRefs.length === 0) ? "" :
        "\tinline Schema* createInstance(std::type_index type) {\n\t\t".concat(generateFieldIfElseChain(allRefs, function (property) { return "type == typeid(".concat(property.childType, ")"); }, function (property) { return "return new ".concat(property.childType, "();"); }, function (property) { return typeMaps[property.childType] === undefined; }), "\n\t\treturn ").concat(klass.extends, "::createInstance(type);\n\t}");
    return "".concat((0, types_1.getCommentHeader)(), "\n#ifndef __SCHEMA_CODEGEN_").concat(klass.name.toUpperCase(), "_H__\n#define __SCHEMA_CODEGEN_").concat(klass.name.toUpperCase(), "_H__ 1\n\n#include \"schema.h\"\n#include <typeinfo>\n#include <typeindex>\n\n").concat(allRefs.
        filter(function (ref) { return ref.childType && typeMaps[ref.childType] === undefined; }).
        map(function (ref) { return ref.childType; }).
        concat((0, types_1.getInheritanceTree)(klass, allClasses, false).map(function (klass) { return klass.name; })).
        filter(distinct).
        map(function (childType) { return "#include \"".concat(childType, ".hpp\""); }).
        join("\n"), "\n\nusing namespace colyseus::schema;\n\n").concat(namespace ? "namespace ".concat(namespace, " {") : "", "\nclass ").concat(klass.name, " : public ").concat(klass.extends, " {\npublic:\n").concat(klass.properties.map(function (prop) { return generateProperty(prop); }).join("\n"), "\n\n\t").concat(klass.name, "() {\n\t\tthis->_indexes = ").concat(generateAllIndexes(allProperties), ";\n\t\tthis->_types = ").concat(generateAllTypes(allProperties), ";\n\t\tthis->_childPrimitiveTypes = ").concat(generateAllChildPrimitiveTypes(allProperties), ";\n\t\tthis->_childSchemaTypes = ").concat(generateAllChildSchemaTypes(allProperties), ";\n\t}\n\n\tvirtual ~").concat(klass.name, "() {\n\t\t").concat(generateDestructors(allProperties).join("\n\t\t"), "\n\t}\n\nprotected:\n").concat(Object.keys(propertiesPerType).map(function (type) {
        return generateGettersAndSetters(klass, type, propertiesPerType[type]);
    }).
        join("\n"), "\n\n").concat(createInstanceMethod, "\n};\n").concat(namespace ? "}" : "", "\n\n#endif\n");
}
function generateProperty(prop) {
    var property = "";
    var langType;
    var initializer = "";
    var isPropPointer = "";
    if (prop.childType) {
        var isUpcaseFirst = prop.childType.match(/^[A-Z]/);
        if (prop.type === "ref") {
            langType = "".concat(prop.childType);
            initializer = "new ".concat(prop.childType, "()");
        }
        else if (prop.type === "array") {
            langType = (isUpcaseFirst)
                ? "ArraySchema<".concat(prop.childType, "*>")
                : "ArraySchema<".concat(typeMaps[prop.childType], ">");
            initializer = "new ".concat(langType, "()");
        }
        else if (prop.type === "map") {
            langType = (isUpcaseFirst)
                ? "MapSchema<".concat(prop.childType, "*>")
                : "MapSchema<".concat(typeMaps[prop.childType], ">");
            initializer = "new ".concat(langType, "()");
        }
        isPropPointer = "*";
    }
    else {
        langType = typeMaps[prop.type];
        initializer = typeInitializer[prop.type];
    }
    property += " ".concat(langType, " ").concat(isPropPointer).concat(prop.name);
    return "\t".concat(property, " = ").concat(initializer, ";");
}
function generateGettersAndSetters(klass, type, properties) {
    var langType = typeMaps[type];
    var typeCast = "";
    var getMethodName = "get".concat(capitalize(type));
    var setMethodName = "set".concat(capitalize(type));
    if (type === "ref") {
        langType = "Schema*";
    }
    else if (type === "array") {
        langType = "ArraySchema<char*> *";
        typeCast = "(ArraySchema<char*> *)";
    }
    else if (type === "map") {
        langType = "MapSchema<char*> *";
        typeCast = "(MapSchema<char*> *)";
    }
    return "\tinline ".concat(langType, " ").concat(getMethodName, "(const string &field)\n\t{\n\t\t").concat(generateFieldIfElseChain(properties, function (property) { return "field == \"".concat(property.name, "\""); }, function (property) { return "return ".concat(typeCast, "this->").concat(property.name, ";"); }), "\n\t\treturn ").concat(klass.extends, "::").concat(getMethodName, "(field);\n\t}\n\n\tinline void ").concat(setMethodName, "(const string &field, ").concat(langType, " value)\n\t{\n\t\t").concat(generateFieldIfElseChain(properties, function (property) { return "field == \"".concat(property.name, "\""); }, function (property) {
        var isSchemaType = (typeMaps[property.childType] === undefined);
        if (type === "ref") {
            langType = "".concat(property.childType, "*");
            typeCast = (isSchemaType)
                ? "(".concat(property.childType, "*)")
                : "/* bug? */";
        }
        else if (type === "array") {
            typeCast = (isSchemaType)
                ? "(ArraySchema<".concat(property.childType, "*> *)")
                : "(ArraySchema<".concat(typeMaps[property.childType], "> *)");
        }
        else if (type === "map") {
            typeCast = (isSchemaType)
                ? "(MapSchema<".concat(property.childType, "*> *)")
                : "(MapSchema<".concat(typeMaps[property.childType], "> *)");
        }
        return "this->".concat(property.name, " = ").concat(typeCast, "value;\n\t\t\treturn;");
    }), "\n\t\treturn ").concat(klass.extends, "::").concat(setMethodName, "(field, value);\n\t}");
}
function generateFieldIfElseChain(properties, ifCallback, callback, filter) {
    if (filter === void 0) { filter = function (_) { return true; }; }
    var chain = "";
    var uniqueChecks = [];
    properties.filter(filter).forEach(function (property, i) {
        var check = ifCallback(property);
        if (uniqueChecks.indexOf(check) === -1) {
            uniqueChecks.push(check);
        }
        else {
            return;
        }
        if (i === 0) {
            chain += "if ";
        }
        else {
            chain += " else if ";
        }
        chain += "(".concat(check, ")\n\t\t{\n\t\t\t").concat(callback(property), "\n\n\t\t}");
    });
    return chain;
}
function generateAllIndexes(properties) {
    return "{".concat(properties.map(function (property, i) { return "{".concat(i, ", \"").concat(property.name, "\"}"); }).join(", "), "}");
}
function generateAllTypes(properties) {
    return "{".concat(properties.map(function (property, i) { return "{".concat(i, ", \"").concat(property.type, "\"}"); }).join(", "), "}");
}
function generateAllChildSchemaTypes(properties) {
    return "{".concat(properties.map(function (property, i) {
        if (property.childType && typeMaps[property.childType] === undefined) {
            return "{".concat(i, ", typeid(").concat(property.childType, ")}");
        }
        else {
            return null;
        }
    }).filter(function (r) { return r !== null; }).join(", "), "}");
}
function generateAllChildPrimitiveTypes(properties) {
    return "{".concat(properties.map(function (property, i) {
        if (typeMaps[property.childType] !== undefined) {
            return "{".concat(i, ", \"").concat(property.childType, "\"}");
        }
        else {
            return null;
        }
    }).filter(function (r) { return r !== null; }).join(", "), "}");
}
function generateDestructors(properties) {
    return properties.map(function (property, i) {
        if (property.childType) {
            return "delete this->".concat(property.name, ";");
        }
        else {
            return null;
        }
    }).filter(function (r) { return r !== null; });
}
function getAllProperties(klass, allClasses) {
    var properties = [];
    (0, types_1.getInheritanceTree)(klass, allClasses).reverse().forEach(function (klass) {
        properties = properties.concat(klass.properties);
    });
    return properties;
}
//# sourceMappingURL=cpp.js.map