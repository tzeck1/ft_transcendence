{
  "version": 3,
  "sources": ["../../src/utils/DevMode.ts"],
  "sourcesContent": ["import debug from \"debug\";\nimport { debugAndPrintError } from \"../Debug\";\n\nimport { getRoomById, handleCreateRoom, presence, remoteRoomCall } from \"../MatchMaker\";\nimport type { Room } from \"../Room\";\n\nexport const debugDevMode = debug('colyseus:devmode');\n\nexport let isDevMode: boolean = false;\n\nexport function setDevMode(bool: boolean) {\n  isDevMode = bool;\n}\n\nexport async function reloadFromCache() {\n  const roomHistoryList = Object.entries(await presence.hgetall(getRoomRestoreListKey()));\n  debugDevMode(\"rooms to restore: %i\", roomHistoryList.length);\n\n  for (const [roomId, value] of roomHistoryList) {\n    let recreatedRoom: Room;\n\n    const roomHistory = JSON.parse(value);\n    debugDevMode(\"restoring room %s (%s)\", roomHistory.roomName, roomId);\n\n    const recreatedRoomListing = await handleCreateRoom(roomHistory.roomName, roomHistory.clientOptions, roomId);\n    console.debug(`\uD83D\uDD04 room '${roomId}' has been restored.`);\n\n    // Set previous state\n    if (roomHistory.hasOwnProperty(\"state\")) {\n      recreatedRoom = getRoomById(recreatedRoomListing.roomId);\n      recreatedRoom.state.decode(roomHistory.state);\n\n      //\n      // WORKAROUND: @colyseus/schema is not capable of encoding a decoded\n      // state. thus, we need a fresh clone immediately after decoding\n      //\n      recreatedRoom.setState(recreatedRoom.state.clone());\n      console.debug(`\uD83D\uDCCB room '${roomId}' state =>`, recreatedRoom.state.toJSON());\n    }\n\n    // call `onRestoreRoom` with custom 'cache'd property.\n    recreatedRoom.onRestoreRoom?.(roomHistory[\"cache\"]);\n\n    // Reserve seats for clients from cached history\n    for (const previousSessionId of roomHistory.clients) {\n      await remoteRoomCall(recreatedRoomListing.roomId, '_reserveSeat',\n        [previousSessionId, {}, 20, false, true]); // reserve seat for 20 seconds\n    }\n  }\n\n  if (roomHistoryList.length > 0) {\n    console.debug(\"\u2705\", roomHistoryList.length, \"room(s) have been restored.\");\n  }\n}\n\nexport async function cacheRoomHistory(rooms: { [roomId: string]: Room }) {\n  for (const room of Object.values(rooms)) {\n    const roomHistoryResult = await presence.hget(getRoomRestoreListKey(), room.roomId);\n    if (roomHistoryResult) {\n      try {\n        const roomHistory = JSON.parse(roomHistoryResult);\n\n        // custom cache method\n        roomHistory[\"cache\"] = room.onCacheRoom?.();\n\n        // encode state\n        debugDevMode(\"caching room %s (%s)\", room.roomName, room.roomId);\n\n        if (room.state) {\n          roomHistory[\"state\"] = room.state.encodeAll();\n        }\n\n        // cache active clients and reserved seats\n        roomHistory[\"clients\"] = room.clients.map((client) => client.sessionId);\n\n        for (const sessionId in room['reservedSeats']) {\n          roomHistory[\"clients\"].push(sessionId);\n        }\n\n        await presence.hset(getRoomRestoreListKey(), room.roomId, JSON.stringify(roomHistory));\n\n        // Rewrite updated room history\n        console.debug(`\uD83D\uDCBE caching room '${room.roomId}' (clients: ${room.clients.length}, state size: ${(roomHistory[\"state\"] || []).length} bytes)`);\n\n      } catch (e) {\n        debugAndPrintError(`\u274C couldn't cache room '${room.roomId}', due to:\\n${e.stack}`);\n      }\n    }\n  }\n}\n\nexport async function getPreviousProcessId(hostname) {\n  return await presence.hget(getProcessRestoreKey(), hostname);\n}\n\nexport function getRoomRestoreListKey() {\n  return 'roomhistory';\n}\n\nexport function getProcessRestoreKey() {\n  return 'processhistory';\n}"],
  "mappings": "AAAA,OAAO,WAAW;AAClB,SAAS,0BAA0B;AAEnC,SAAS,aAAa,kBAAkB,UAAU,sBAAsB;AAGjE,MAAM,eAAe,MAAM,kBAAkB;AAE7C,IAAI,YAAqB;AAEzB,SAAS,WAAW,MAAe;AACxC,cAAY;AACd;AAEA,eAAsB,kBAAkB;AACtC,QAAM,kBAAkB,OAAO,QAAQ,MAAM,SAAS,QAAQ,sBAAsB,CAAC,CAAC;AACtF,eAAa,wBAAwB,gBAAgB,MAAM;AAE3D,aAAW,CAAC,QAAQ,KAAK,KAAK,iBAAiB;AAC7C,QAAI;AAEJ,UAAM,cAAc,KAAK,MAAM,KAAK;AACpC,iBAAa,0BAA0B,YAAY,UAAU,MAAM;AAEnE,UAAM,uBAAuB,MAAM,iBAAiB,YAAY,UAAU,YAAY,eAAe,MAAM;AAC3G,YAAQ,MAAM,mBAAY,4BAA4B;AAGtD,QAAI,YAAY,eAAe,OAAO,GAAG;AACvC,sBAAgB,YAAY,qBAAqB,MAAM;AACvD,oBAAc,MAAM,OAAO,YAAY,KAAK;AAM5C,oBAAc,SAAS,cAAc,MAAM,MAAM,CAAC;AAClD,cAAQ,MAAM,mBAAY,oBAAoB,cAAc,MAAM,OAAO,CAAC;AAAA,IAC5E;AAGA,kBAAc,gBAAgB,YAAY,QAAQ;AAGlD,eAAW,qBAAqB,YAAY,SAAS;AACnD,YAAM;AAAA,QAAe,qBAAqB;AAAA,QAAQ;AAAA,QAChD,CAAC,mBAAmB,CAAC,GAAG,IAAI,OAAO,IAAI;AAAA,MAAC;AAAA,IAC5C;AAAA,EACF;AAEA,MAAI,gBAAgB,SAAS,GAAG;AAC9B,YAAQ,MAAM,UAAK,gBAAgB,QAAQ,6BAA6B;AAAA,EAC1E;AACF;AAEA,eAAsB,iBAAiB,OAAmC;AACxE,aAAW,QAAQ,OAAO,OAAO,KAAK,GAAG;AACvC,UAAM,oBAAoB,MAAM,SAAS,KAAK,sBAAsB,GAAG,KAAK,MAAM;AAClF,QAAI,mBAAmB;AACrB,UAAI;AACF,cAAM,cAAc,KAAK,MAAM,iBAAiB;AAGhD,oBAAY,WAAW,KAAK,cAAc;AAG1C,qBAAa,wBAAwB,KAAK,UAAU,KAAK,MAAM;AAE/D,YAAI,KAAK,OAAO;AACd,sBAAY,WAAW,KAAK,MAAM,UAAU;AAAA,QAC9C;AAGA,oBAAY,aAAa,KAAK,QAAQ,IAAI,CAAC,WAAW,OAAO,SAAS;AAEtE,mBAAW,aAAa,KAAK,kBAAkB;AAC7C,sBAAY,WAAW,KAAK,SAAS;AAAA,QACvC;AAEA,cAAM,SAAS,KAAK,sBAAsB,GAAG,KAAK,QAAQ,KAAK,UAAU,WAAW,CAAC;AAGrF,gBAAQ,MAAM,2BAAoB,KAAK,qBAAqB,KAAK,QAAQ,wBAAwB,YAAY,YAAY,CAAC,GAAG,eAAe;AAAA,MAE9I,SAAS,GAAP;AACA,2BAAmB,+BAA0B,KAAK;AAAA,EAAqB,EAAE,OAAO;AAAA,MAClF;AAAA,IACF;AAAA,EACF;AACF;AAEA,eAAsB,qBAAqB,UAAU;AACnD,SAAO,MAAM,SAAS,KAAK,qBAAqB,GAAG,QAAQ;AAC7D;AAEO,SAAS,wBAAwB;AACtC,SAAO;AACT;AAEO,SAAS,uBAAuB;AACrC,SAAO;AACT;",
  "names": []
}
